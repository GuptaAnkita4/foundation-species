control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS")))
)
one_sided_dispersion <- function(mod, dat, response, nsim = 1000L) {
res <- try(simulateResiduals(mod, n = nsim, plot = FALSE), silent = TRUE)
if (inherits(res, "try-error")) return(tibble::tibble(two_sided = NA, over_p = NA, under_p = NA))
tibble::tibble(
two_sided = tryCatch(testDispersion(res)$p.value, error = function(e) NA_real_),
over_p    = tryCatch(testDispersion(res, alternative = "greater")$p.value, error = function(e) NA_real_),
under_p   = tryCatch(testDispersion(res, alternative = "less")$p.value,    error = function(e) NA_real_)
)
}
compare_models <- function(named_models, data_name) {
# AIC table
aic_tab <- purrr::map_dfr(names(named_models), function(nm) {
m <- named_models[[nm]]
tibble::tibble(model_name = nm,
family     = as.character(family(m)$family),
logLik     = as.numeric(logLik(m)),
AIC        = AIC(m),
BIC        = BIC(m),
nobs       = stats::nobs(m))
})
aic_tab <- aic_tab |>
dplyr::arrange(AIC) |>
dplyr::mutate(deltaAIC = AIC - min(AIC),
weight = exp(-0.5*deltaAIC) / sum(exp(-0.5*deltaAIC)))
readr::write_csv(aic_tab, file.path(alt_dir, paste0(data_name, "_AIC_compare.csv")))
aic_tab
}
disp_dir <- one_sided_dispersion(troph_rich_A.s, s.sparea.troph, "richness")
readr::write_csv(disp_dir, file.path(alt_dir, "s_rich_A_dispersion_direction.csv"))
cand_s_rich_A <- list(
NB2_base   = troph_rich_A.s,
NB1_base   = glmmTMB(richness ~ logArea * factor(trophLevel) + (1|grid),
data = s.sparea.troph, family = nbinom1,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))),
NB2_disp   = glmmTMB(richness ~ logArea * factor(trophLevel) + (1|grid),
dispformula = ~ logArea * factor(trophLevel),
data = s.sparea.troph, family = nbinom2,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))),
ZINB2      = glmmTMB(richness ~ logArea * factor(trophLevel) + (1|grid),
ziformula = ~ logArea + factor(trophLevel),
data = s.sparea.troph, family = nbinom2,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))),
COMPoisson = glmmTMB(richness ~ logArea * factor(trophLevel) + (1|grid),
data = s.sparea.troph, family = glmmTMB::compois(),
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS")))
)
# ---------------------------------------------------------------------
# FAST + SAFE model diagnostics (timeouts + smaller sims)
# ---------------------------------------------------------------------
suppressPackageStartupMessages({
library(DHARMa)
library(R.utils)   # install.packages("R.utils") if missing
})
DIAG_DIR <- file.path(OUT_DIR, "diagnostics")
fs::dir_create(DIAG_DIR, recurse = TRUE)
# Tunables
NSIM_RESID  <- 250L    # was 1000
NSIM_ZERO   <- 200L    # was 500
TIMEOUT_SEC <- 20      # seconds per heavy call
TRY_ZI         <- TRUE
TRY_COMPOISSON <- FALSE   # COM-Poisson is often the culprit; enable only if needed
set.seed(123)
is_count_like <- function(v) is.numeric(v) && all(is.na(v) | v >= 0) && all(is.na(v) | abs(v - round(v)) < .Machine$double.eps^0.5)
safe_with_timeout <- function(expr, timeout = TIMEOUT_SEC) {
try(withTimeout(expr, timeout = timeout, onTimeout = "error"), silent = TRUE)
}
get_dharma <- function(mod, dat, response, nsim_resid = NSIM_RESID) {
# 1) standard route (no refit)
res <- safe_with_timeout(DHARMa::simulateResiduals(fittedModel = mod, n = nsim_resid, plot = FALSE, refit = FALSE))
if (!inherits(res, "try-error") && inherits(res, "DHARMa")) return(res)
# 2) fallback via createDHARMa
sim <- safe_with_timeout(stats::simulate(mod, nsim = nsim_resid))
fit <- try(predict(mod, type = "response"), silent = TRUE)
if (inherits(sim, "try-error") || inherits(fit, "try-error")) return(NULL)
simmat <- try(as.matrix(sim), silent = TRUE)
if (inherits(simmat, "try-error")) return(NULL)
intResp <- is_count_like(dat[[response]])
res2 <- try(DHARMa::createDHARMa(simulatedResponse = simmat,
observedResponse  = dat[[response]],
fittedPredicted   = fit,
integerResponse   = intResp),
silent = TRUE)
if (inherits(res2, "try-error")) NULL else res2
}
safe_plot <- function(fun) try(fun(), silent = TRUE)
diag_glmmTMB <- function(mod, dat, response, name, xvar = NULL, group = NULL,
nsim_resid = NSIM_RESID, nsim_zero = NSIM_ZERO, outdir = DIAG_DIR) {
res <- get_dharma(mod, dat, response, nsim_resid)
dharma_ok <- inherits(res, "DHARMa") && is.numeric(res$scaledResiduals)
# Plots (only if DHARMa ok)
if (dharma_ok) {
safe_plot(function() {
png(file.path(outdir, paste0(name, "_DHARMa_overview.png")), 1600, 1200, res = 180)
plot(res); dev.off()
})
fv <- try(predict(mod, type = "response"), silent = TRUE)
if (!inherits(fv, "try-error")) {
safe_plot(function() {
png(file.path(outdir, paste0(name, "_resid_vs_fitted.png")), 1600, 1200, res = 180)
DHARMa::plotResiduals(fv, res$scaledResiduals, quantreg = TRUE, xlab = "Fitted (response)")
dev.off()
})
}
if (!is.null(xvar) && xvar %in% names(dat)) {
safe_plot(function() {
png(file.path(outdir, paste0(name, "_resid_vs_", xvar, ".png")), 1600, 1200, res = 180)
DHARMa::plotResiduals(dat[[xvar]], res$scaledResiduals, quantreg = TRUE, xlab = xvar)
dev.off()
})
}
if (!is.null(group) && group %in% names(dat)) {
safe_plot(function() {
png(file.path(outdir, paste0(name, "_resid_by_", group, ".png")), 1600, 1200, res = 180)
DHARMa::plotResiduals(as.factor(dat[[group]]), res$scaledResiduals, xlab = group)
dev.off()
})
}
}
# DHARMa tests (guarded)
unif_p <- disp_p <- zi_p <- NA_real_
if (dharma_ok) {
tu <- try(DHARMa::testUniformity(res), silent = TRUE); if (!inherits(tu, "try-error")) unif_p <- tu$p.value
td <- try(DHARMa::testDispersion(res), silent = TRUE); if (!inherits(td, "try-error")) disp_p <- td$p.value
tz <- try(DHARMa::testZeroInflation(res), silent = TRUE); if (!inherits(tz, "try-error")) zi_p <- tz$p.value
}
# Expected zero rate (timed)
exp_zero_rate <- NA_real_
simlist <- safe_with_timeout(stats::simulate(mod, nsim = nsim_zero))
if (!inherits(simlist, "try-error")) {
simmat <- try(as.matrix(simlist), silent = TRUE)
if (!inherits(simmat, "try-error")) {
p0_hat <- rowMeans(simmat == 0, na.rm = TRUE)
exp_zero_rate <- mean(p0_hat, na.rm = TRUE)
readr::write_csv(
tibble::tibble(obs_zero = as.integer(dat[[response]] == 0), exp_zero_prob = p0_hat),
file.path(outdir, paste0(name, "_expected_zero_prob_by_row.csv"))
)
}
}
obs_zero_rate <- mean(dat[[response]] == 0, na.rm = TRUE)
# Residuals table (if available)
if (dharma_ok) {
fv <- try(predict(mod, type = "response"), silent = TRUE)
if (!inherits(fv, "try-error")) {
tibble::tibble(fitted = fv, scaled_residual = res$scaledResiduals, response = dat[[response]]) |>
readr::write_csv(file.path(outdir, paste0(name, "_residuals.csv")))
}
}
tibble::tibble(
model = name,
nsim_resid = nsim_resid,
nsim_zero  = nsim_zero,
uniformity_p = unif_p,
dispersion_p = disp_p,
zeroinfl_p   = zi_p,
spatial_p    = NA_real_,
observed_zero_rate = obs_zero_rate,
expected_zero_rate = exp_zero_rate,
dharma_ok = dharma_ok
)
}
diag_specs <- list(
s_rich_A = list(mod = troph_rich_A.s,  dat = s.sparea.troph,   response = "richness", xvar = "logArea", group = "trophLevel"),
s_rich_W = list(mod = troph_rich_WV.s, dat = s.sparea.troph,   response = "richness", xvar = "logWV",   group = "trophLevel"),
s_cnt_A  = list(mod = troph_count_A.s, dat = s.spcount.troph,  response = "count",    xvar = "logArea", group = "trophLevel"),
s_cnt_W  = list(mod = troph_count_WV.s,dat = s.spcount.troph,  response = "count",    xvar = "logWV",   group = "trophLevel"),
w_rich_A = list(mod = troph_rich_A.w,  dat = w.sparea.troph,   response = "richness", xvar = "logArea", group = "trophLevel"),
w_rich_W = list(mod = troph_rich_WV.w, dat = w.sparea.troph,   response = "richness", xvar = "logWV",   group = "trophLevel"),
w_cnt_A  = list(mod = troph_count_A.w, dat = w.spcount.troph,  response = "count",    xvar = "logArea", group = "trophLevel"),
w_cnt_W  = list(mod = troph_count_WV.w,dat = w.spcount.troph,  response = "count",    xvar = "logWV",   group = "trophLevel")
)
diag_summary <- purrr::imap_dfr(diag_specs, function(sp, nm) {
diag_glmmTMB(sp$mod, sp$dat, response = sp$response, name = nm,
xvar = sp$xvar, group = sp$group)
})
readr::write_csv(diag_summary, file.path(DIAG_DIR, "diagnostics_summary.csv"))
message("ðŸ©º Diagnostics written to: ", DIAG_DIR)
# ---------------------------------------------------------------------
# FAST alternatives only for flagged models (skip slow families by default)
# ---------------------------------------------------------------------
alt_dir <- file.path(OUT_DIR, "alternatives_fast")
fs::dir_create(alt_dir, recurse = TRUE)
one_sided_dispersion <- function(mod) {
res <- get_dharma(mod, dat = data.frame(), response = NULL, nsim_resid = 200L)
if (!inherits(res, "DHARMa")) return(tibble::tibble(two_sided = NA, over_p = NA, under_p = NA))
tibble::tibble(
two_sided = tryCatch(testDispersion(res)$p.value, error = function(e) NA_real_),
over_p    = tryCatch(testDispersion(res, alternative = "greater")$p.value, error = function(e) NA_real_),
under_p   = tryCatch(testDispersion(res, alternative = "less")$p.value,    error = function(e) NA_real_)
)
}
safe_fit <- function(expr) safe_with_timeout(expr, timeout = TIMEOUT_SEC)
fit_candidates <- function(base_mod, form, data, family_nb2 = nbinom2, fam_label = "A") {
cands <- list()
# NB2 base (already fitted)
cands[[paste0("NB2_base_", fam_label)]] <- base_mod
# NB1
nb1 <- safe_fit(glmmTMB(form, data = data, family = nbinom1,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))))
if (!inherits(nb1, "try-error")) cands[[paste0("NB1_base_", fam_label)]] <- nb1
# NB2 with dispformula
nb2d <- safe_fit(glmmTMB(form, dispformula = ~ ., data = data, family = nbinom2,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))))
if (!inherits(nb2d, "try-error")) cands[[paste0("NB2_disp_", fam_label)]] <- nb2d
# ZINB (optional)
if (TRY_ZI) {
zi <- safe_fit(glmmTMB(form, ziformula = ~ ., data = data, family = nbinom2,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))))
if (!inherits(zi, "try-error")) cands[[paste0("ZINB2_", fam_label)]] <- zi
}
# COM-Poisson (optional, slow)
if (TRY_COMPOISSON) {
cp <- safe_fit(glmmTMB(form, data = data, family = glmmTMB::compois(),
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))))
if (!inherits(cp, "try-error")) cands[[paste0("COMPoisson_", fam_label)]] <- cp
}
cands
}
compare_models <- function(named_models, tag) {
keep <- purrr::keep(named_models, ~ !inherits(.x, "try-error"))
if (length(keep) == 0) return(invisible(NULL))
tab <- purrr::map_dfr(names(keep), function(nm) {
m <- keep[[nm]]
tibble::tibble(model_name = nm,
logLik = tryCatch(as.numeric(logLik(m)), error = function(e) NA_real_),
AIC    = tryCatch(AIC(m),                    error = function(e) NA_real_),
BIC    = tryCatch(BIC(m),                    error = function(e) NA_real_),
nobs   = tryCatch(stats::nobs(m),            error = function(e) NA_real_))
}) |>
dplyr::filter(is.finite(AIC)) |>
dplyr::arrange(AIC) |>
dplyr::mutate(deltaAIC = AIC - min(AIC),
weight   = exp(-0.5*deltaAIC) / sum(exp(-0.5*deltaAIC)))
if (nrow(tab)) readr::write_csv(tab, file.path(alt_dir, paste0(tag, "_AIC_compare.csv")))
tab
}
# Only re-fit alternatives for the two flagged summer richness models
# 1) s_rich_A
cand_A <- fit_candidates(
base_mod = troph_rich_A.s,
form     = richness ~ logArea * factor(trophLevel) + (1|grid),
data     = s.sparea.troph,
fam_label = "s_rich_A"
)
tab_A <- compare_models(cand_A, "s_rich_A")
if (!is.null(tab_A) && nrow(tab_A)) print(tab_A)
# 2) s_rich_W
cand_W <- fit_candidates(
base_mod = troph_rich_WV.s,
form     = richness ~ logWV * factor(trophLevel) + (1|grid),
data     = s.sparea.troph,
fam_label = "s_rich_W"
)
tab_W <- compare_models(cand_W, "s_rich_W")
if (!is.null(tab_W) && nrow(tab_W)) print(tab_W)
# scripts/04_trophic_SAR_by_level.R
suppressPackageStartupMessages({
library(here)
library(dplyr); library(tidyr); library(ggplot2); library(cowplot)
library(car); library(emmeans); library(multcomp); library(patchwork)
library(MASS); library(glmmTMB); library(ggeffects)
library(readr); library(fs); library(purrr)
})
# ---------------------------------------------------------------------
# Preconditions (stop early if required columns missing)
# ---------------------------------------------------------------------
need_rich_cols <- c("grid","logArea","logWV","trophLevel","richness")
need_cnt_cols  <- c("grid","logArea","logWV","trophLevel","count")
stopifnot(
exists("s.sparea.troph"), exists("w.sparea.troph"),
exists("s.spcount.troph"), exists("w.spcount.troph")
)
source("~/GitHub/foundation-species/scripts/04_area-trophic-interaction.R")
# ---------------------------------------------------------------------
# Models (NB2; unchanged)
# ---------------------------------------------------------------------
troph_rich_A.s <- glmmTMB(
richness ~ logArea * factor(trophLevel) + (1|grid),
data = s.sparea.troph, family = nbinom2,
control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS"))
)
summary(troph_rich_A.s)
# ---------------------------------------------------------------------
# Plots (AREA Ã— trophic level): 2Ã—2 (Summer/Winter Ã— Richness/Abundance)
# ---------------------------------------------------------------------
richWVtroph.s <- ggplot(pred_rich_A.s, aes(x = x, y = ty_rich(predicted), color = group)) +
annotate("text",
x = min(pred_rich_A.s$x, na.rm = TRUE) + 0.1 * diff(range(pred_rich_A.s$x, na.rm = TRUE)),
y = min(ylim_rich) + 0.95 * diff(range(ylim_rich)),
label = "p>0.05", size = 3, hjust = 0) +
# geom_point(data = s.sparea.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
# + position_jitter(width = 0.03, height = 0)  # optional
geom_line(linewidth = 1.1) +
labs(title = "Summer", x = "log2(Wetland Area)", y = y_lab_rich, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophrich_labels, drop = FALSE) +
scale_x_continuous(limits = xlim_rich) + scale_y_continuous(limits = ylim_rich) +
custom_theme
richWVtroph.w <- ggplot(pred_rich_A.w, aes(x = x, y = ty_rich(predicted), color = group)) +
annotate("text",
x = min(pred_rich_A.w$x, na.rm = TRUE) + 0.1 * diff(range(pred_rich_A.w$x, na.rm = TRUE)),
y = min(ylim_rich) + 0.95 * diff(range(ylim_rich)),
label = "p<0.01", size = 3, hjust = 0) +
# geom_point(data = w.sparea.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Winter", x = "log2(Wetland Area)", y = NULL, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophrich_labels, drop = FALSE) +
scale_x_continuous(limits = xlim_rich) + scale_y_continuous(limits = ylim_rich) +
custom_theme
countWVtroph.s <- ggplot(pred_count_A.s, aes(x = x, y = ty_cnt(predicted), color = group)) +
annotate("text",
x = min(pred_count_A.s$x, na.rm = TRUE) + 0.1 * diff(range(pred_count_A.s$x, na.rm = TRUE)),
y = min(ylim_abund) + 0.95 * diff(range(ylim_abund)),
label = "p<0.001", size = 3, hjust = 0) +
# geom_point(data = s.spcount.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Summer", x = "log2(Wetland Area)", y = y_lab_abund, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophcount_labels, drop = FALSE) +
scale_x_continuous(limits = xlim_abund) + scale_y_continuous(limits = ylim_abund) +
custom_theme
countWVtroph.w <- ggplot(pred_count_A.w, aes(x = x, y = ty_cnt(predicted), color = group)) +
annotate("text",
x = min(pred_count_A.w$x, na.rm = TRUE) + 0.1 * diff(range(pred_count_A.w$x, na.rm = TRUE)),
y = min(ylim_abund) + 0.95 * diff(range(ylim_abund)),
label = "p<0.01", size = 3, hjust = 0) +
# geom_point(data = w.spcount.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Winter", x = "log2(Wetland Area)", y = NULL, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophcount_labels, drop = FALSE) +
scale_x_continuous(limits = xlim_abund) + scale_y_continuous(limits = ylim_abund) +
custom_theme
combined_plot <- (
richWVtroph.s + richWVtroph.w + plot_spacer() + countWVtroph.s + countWVtroph.w
) +
plot_layout(ncol = 5, widths = c(1, 1, 0.05, 1, 1), guides = "collect") +
plot_annotation(tag_levels = 'a') &
theme(
legend.position = "bottom",
legend.direction = "horizontal",
legend.title = element_text(size = 12),
legend.text  = element_text(size = 11)
)
# Save figure to Figures/
ggsave(here("Figures", "troph_A_combined_color.png"),
combined_plot, width = 1400/120, height = 500/120, dpi = 120, units = "in")
source("~/GitHub/foundation-species/scripts/04_area-trophic-interaction.R")
# ---------------------------------------------------------------------
# Plots (AREA Ã— trophic level): 2Ã—2 (Summer/Winter Ã— Richness/Abundance)
# ---------------------------------------------------------------------
richWVtroph.s <- ggplot(pred_rich_A.s, aes(x = x, y = tlog_line(predicted), color = group)) +
annotate("text",
x = min(pred_rich_A.s$x, na.rm = TRUE) + 0.1 * diff(range(pred_rich_A.s$x, na.rm = TRUE)),
y = min(ylim_rich) + 0.95 * diff(range(ylim_rich)),
label = "p>0.05", size = 3, hjust = 0) +
# geom_point(data = s.sparea.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Summer", x = "log2(Wetland Area)", y = y_lab_rich, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophrich_labels, drop = FALSE, na.translate = FALSE) +
scale_x_continuous(limits = xlim_rich) + scale_y_continuous(limits = ylim_rich) +
custom_theme
richWVtroph.w <- ggplot(pred_rich_A.w, aes(x = x, y = tlog_line(predicted), color = group)) +
annotate("text",
x = min(pred_rich_A.w$x, na.rm = TRUE) + 0.1 * diff(range(pred_rich_A.w$x, na.rm = TRUE)),
y = min(ylim_rich) + 0.95 * diff(range(ylim_rich)),
label = "p<0.01", size = 3, hjust = 0) +
# geom_point(data = w.sparea.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Winter", x = "log2(Wetland Area)", y = NULL, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophrich_labels, drop = FALSE, na.translate = FALSE) +
scale_x_continuous(limits = xlim_rich) + scale_y_continuous(limits = ylim_rich) +
custom_theme
countWVtroph.s <- ggplot(pred_count_A.s, aes(x = x, y = tlog_line(predicted), color = group)) +
annotate("text",
x = min(pred_count_A.s$x, na.rm = TRUE) + 0.1 * diff(range(pred_count_A.s$x, na.rm = TRUE)),
y = min(ylim_abund) + 0.95 * diff(range(ylim_abund)),
label = "p<0.001", size = 3, hjust = 0) +
# geom_point(data = s.spcount.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Summer", x = "log2(Wetland Area)", y = y_lab_abund, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophcount_labels, drop = FALSE, na.translate = FALSE) +
scale_x_continuous(limits = xlim_abund) + scale_y_continuous(limits = ylim_abund) +
custom_theme
countWVtroph.w <- ggplot(pred_count_A.w, aes(x = x, y = tlog_line(predicted), color = group)) +
annotate("text",
x = min(pred_count_A.w$x, na.rm = TRUE) + 0.1 * diff(range(pred_count_A.w$x, na.rm = TRUE)),
y = min(ylim_abund) + 0.95 * diff(range(ylim_abund)),
label = "p<0.01", size = 3, hjust = 0) +
# geom_point(data = w.spcount.troph, aes(x = logArea, y = y_plot, color = group),
#            inherit.aes = FALSE, alpha = 0.45, size = 1.8, stroke = 0) +
geom_line(linewidth = 1.1) +
labs(title = "Winter", x = "log2(Wetland Area)", y = NULL, color = "Trophic Level") +
scale_color_manual(values = okabe_ito, labels = trophcount_labels, drop = FALSE, na.translate = FALSE) +
scale_x_continuous(limits = xlim_abund) + scale_y_continuous(limits = ylim_abund) +
custom_theme
combined_plot <- (
richWVtroph.s + richWVtroph.w + plot_spacer() + countWVtroph.s + countWVtroph.w
) +
plot_layout(ncol = 5, widths = c(1, 1, 0.05, 1, 1), guides = "collect") +
plot_annotation(tag_levels = 'a') &
theme(
legend.position = "bottom",
legend.direction = "horizontal",
legend.title = element_text(size = 12),
legend.text  = element_text(size = 11)
)
# Save figure to Figures/
ggsave(here("Figures", "troph_A_combined_color.png"),
combined_plot, width = 1400/120, height = 500/120, dpi = 120, units = "in")
source("~/GitHub/foundation-species/scripts/03_species-area-foundationspecies-models.R")
# ---------------------- Plotting (pure log everywhere) -----------------------
make_wv_plot <- function(pred_data, obs_data, season_label, yvar_logcol,
annotation_text, ylab_text, xlims = NULL, ylims = NULL) {
pred_data <- as.data.frame(pred_data)
pred_data$line_group <- factor(pred_data$group, levels = c("0","1","2"))
obs_data$point_group <- factor(obs_data$WVclass, levels = c("0","1","2"))
fill_vals  <- c("0" = "#009E73", "1" = "#E69F00", "2" = "#CC79A7")
shape_vals <- c("0" = 21, "1" = 22, "2" = 24)
line_vals  <- c("0" = "#007256", "1" = "#B66F00", "2" = "#994C8D")
wv_labels  <- c("Low (<30%)", "Medium (30â€“70%)", "High (>70%)")
if (is.null(xlims)) xlims <- range(c(obs_data$logArea, pred_data$x), na.rm = TRUE)
if (is.null(ylims)) ylims <- range(obs_data[[yvar_logcol]], na.rm = TRUE)
ggplot() +
# POINTS (observed; already on log scale)
# geom_jitter(
#   data = obs_data,
#   aes(x = logArea, y = .data[[yvar_logcol]], shape = point_group, fill = point_group),
#   width = 0.1, alpha = 0.4, size = 2, stroke = 0.4, color = "black"
# ) +
# # LINES (predicted; log of the mean)
geom_line(
data = pred_data,
aes(x = x, y = tlog_line(predicted), color = line_group, group = line_group),
linewidth = 1, inherit.aes = FALSE
) +
annotate("text",
x = min(obs_data$logArea, na.rm = TRUE) + 0.5,
y = min(ylims, na.rm = TRUE) + 0.95 * diff(range(ylims, na.rm = TRUE)),
label = annotation_text, size = 4, hjust = 0
) +
scale_shape_manual(values = shape_vals, labels = wv_labels, name = "Points: % Wetland Vegetation") +
scale_fill_manual(values = fill_vals,  labels = wv_labels, name = "Points: % Wetland Vegetation") +
scale_color_manual(values = line_vals, labels = wv_labels, name = "% Wetland Vegetation") +
labs(title = season_label, x = "log2(Wetland Area)", y = ylab_text) +
scale_x_continuous(limits = xlims) +
scale_y_continuous(limits = ylims) +
theme_bw(base_size = 12) +
theme(
panel.grid = element_blank(),
plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
axis.title = element_text(size = 14),
axis.text  = element_text(size = 14),
legend.position = "bottom",
legend.title = element_text(size = 12),
legend.text  = element_text(size = 12)
) +
guides(
color = guide_legend(override.aes = list(linewidth = 2), order = 1),
fill  = guide_legend(override.aes = list(size = 2), order = 2),
shape = guide_legend(override.aes = list(size = 2), order = 2)
)
}
# axis limits using log(y) (safe via +epsilon in normalize_glm_dat)
xlim_rich  <- range(c(s.glm.dat$logArea, w.glm.dat$logArea), na.rm = TRUE)
ylim_rich  <- range(c(s.glm.dat$log_rich, w.glm.dat$log_rich), na.rm = TRUE)
xlim_abund <- xlim_rich
ylim_abund <- range(c(s.glm.dat$log_abun, w.glm.dat$log_abun), na.rm = TRUE)
p_a <- make_wv_plot(pred_rich_s,  s.glm.dat, "Summer", "log_rich", lab_rich_s,  "log(Richness)",  xlim_rich,  ylim_rich)
p_b <- make_wv_plot(pred_rich_w,  w.glm.dat, "Winter", "log_rich", lab_rich_w,  "log(Richness)",  xlim_rich,  ylim_rich) + labs(y = NULL)
p_c <- make_wv_plot(pred_count_s, s.glm.dat, "Summer", "log_abun", lab_count_s, "log(Abundance)", xlim_abund, ylim_abund)
p_d <- make_wv_plot(pred_count_w, w.glm.dat, "Winter", "log_abun", lab_count_w, "log(Abundance)", xlim_abund, ylim_abund) + labs(y = NULL)
combined_plot <- (
(p_a + p_b + plot_spacer() + p_c + p_d) +
plot_layout(ncol = 5, widths = c(1, 1, 0.05, 1, 1), guides = "collect") +
plot_annotation(tag_levels = "a") &
theme(
legend.position = "bottom",
legend.title = element_text(size = 12),
legend.text  = element_text(size = 12)
) &
guides(
color = guide_legend(nrow = 2),
fill  = guide_legend(nrow = 2),
shape = guide_legend(nrow = 2)
)
)
# Save outputs
ggsave(here("Figures", "SAR_WV_combined_color.png"), combined_plot, width = 14, height = 5, dpi = 600)
combined_plot <- (
(p_a + p_b + plot_spacer() + p_c + p_d) +
plot_layout(ncol = 5, widths = c(1, 1, 0.05, 1, 1), guides = "collect") +
plot_annotation(tag_levels = "a") &
theme(
legend.position = "bottom",
legend.title = element_text(size = 12),
legend.text  = element_text(size = 12)
) &
guides(
color = guide_legend(nrow = 1),
fill  = guide_legend(nrow = 1),
shape = guide_legend(nrow = 1)
)
)
# Save outputs
ggsave(here("Figures", "SAR_WV_combined_color.png"), combined_plot, width = 14, height = 5, dpi = 600)
